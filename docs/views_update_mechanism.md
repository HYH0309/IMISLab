# 阅读量统计与更新机制说明

## 📊 更新频率总结

| 层级 | 更新时机 | 更新频率 | 说明 |
|------|----------|----------|------|
| **Redis缓存** | 用户访问时 | 实时 | 立即响应，但有防刷限制 |
| **数据库持久化** | 定时同步 | 每5分钟 | 将Redis数据同步到MySQL |
| **前端显示** | 页面加载时 | 实时 | 通过API获取最新数据 |

## 🔄 详细工作流程

### 1. 用户访问文章

```
用户访问 → 检查IP防刷 → Redis阅读量+1 → 立即返回新数据
```

### 2. 防刷机制

```
同一IP + 同一文章 + 1小时内 = 不增加阅读量
不同IP + 同一文章 = 正常增加阅读量
```

### 3. 数据持久化

```
每5分钟 → 扫描Redis中所有文章阅读量 → 批量同步到MySQL数据库
```

### 4. 前端显示

```
页面加载 → 调用API → 获取数据库最新数据 → 显示在ArticleCard
```

## ⚡ 性能特点

### 优势

- **实时性强**：用户访问时立即在Redis中更新，前端能看到最新数据
- **高性能**：Redis内存操作，响应速度快
- **数据安全**：定时同步确保数据不丢失
- **防刷有效**：基于IP的重复访问控制

### 时间延迟

- **用户看到自己的访问效果**：立即（0延迟）
- **其他用户看到更新**：立即（通过API实时获取Redis数据）
- **数据库中的持久化**：最多5分钟延迟

## 🔧 技术实现

### Redis键设计

```
article:views:123     # 文章123的总阅读量
article:ip:123_1.2.3.4  # IP 1.2.3.4 访问文章123的记录
```

### 同步任务

```go
// 每5分钟执行一次
ticker := time.NewTicker(5 * time.Minute)
```

### API响应

前端调用文章API时，返回的数据包含实时的`views`字段：

```json
{
  "id": 29,
  "title": "文章标题",
  "views": 156,  // 实时阅读量
  "createdAt": "2025-06-17 20:21:11"
}
```

## 📱 前端显示行为

### ArticleCard组件

- 每次组件渲染时显示最新的阅读量
- 用户刷新页面时会看到最新数据
- 阅读量显示格式：👁 156

### 更新触发时机

1. **页面首次加载**：获取所有文章的最新阅读量
2. **用户刷新页面**：重新获取最新数据
3. **路由切换**：重新加载文章列表
4. **用户访问文章详情后返回列表**：会看到该文章阅读量+1

## 🎯 用户体验

### 正常情况

- 用户访问文章 → 立即看到阅读量+1
- 其他用户刷新页面 → 看到最新的阅读量

### 防刷情况  

- 同一用户1小时内重复访问 → 阅读量不变
- 恶意刷新攻击 → 被有效阻止

## 🔍 监控与日志

系统会记录以下信息：

- 每次阅读量更新
- 防刷机制触发
- 定时同步执行状态
- Redis与数据库同步结果

---

**总结**：阅读量在用户访问时实时更新，前端显示也是实时的，数据每5分钟持久化到数据库确保数据安全。
